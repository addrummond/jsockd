diff --git a/quickjs-libc.c b/quickjs-libc.c
index 54a7a15..e0dd552 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -4277,8 +4277,14 @@ JSValue js_std_await(JSContext *ctx, JSValue obj)
             if (err == 0) {
                 js_std_promise_rejection_check(ctx);
 
-                if (os_poll_func)
-                    os_poll_func(ctx);
+                // Alex D: Attempt to guard agasint an infinite loop that I caused by
+                // setting globalThis.setTimeout = () => {}. This infinite loop is
+                // nasty because it's immune to JS_SetInterrupt. User code shouldn't
+                // be able to lock the interpreter like this (however dumb it is).
+                if (! os_poll_func || os_poll_func(ctx)) {
+                    JS_FreeValue(ctx, obj);
+                    return JS_EXCEPTION;
+                }
             }
         } else {
             /* not a promise */
diff --git a/quickjs.c b/quickjs.c
index 92a7297..755e864 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -2006,9 +2006,11 @@ void JS_FreeRuntime(JSRuntime *rt)
         if (count != 0)
             printf("Secondary object leaks: %d\n", count);
     }
-#endif
+#else
+    // Alex D: These assertions cause an early exit which then makes Valgrind less useful, as tons of stuff is left unfreed.
     assert(list_empty(&rt->gc_obj_list));
     assert(list_empty(&rt->weakref_list));
+#endif
 
     /* free the classes */
     for(i = 0; i < rt->class_count; i++) {
