# JSockD

JSockD provides a lightweight multi-threaded server for executing parameterized JavaScript commands.
The server receives commands over one or more UNIX domain sockets. The motivating use case is server-side rendering of React components.

- Uses the lightweight [QuickJS](https://bellard.org/quickjs/) JavaScript engine
- Loads precompiled bytecode for fast startup and execution
- Caches command bytecode
- Low memory usage
- Valgrind tests, fuzz tests

## 1. Using JSockD

### 1.1 Setting up JSockD for your application

Applications should generally connect to JSockD via a client library that manages the JSockD server process. At the moment, this repo contains one example of such a library in `clients/elixir/jsockd_client`. At this level of abstraction, JSockD is a simple command execution service. Commands are JavaScript functions executed with specified parameters.

Steps to add JSockD to your application:

* Bundle all of the required Javascript library code into a single ES6 module. [Esbuild](https://esbuild.github.io/api/) is one example of a suitable bundler.
* Compile the ES6 module into a QuickJS bytecode file using the `compile_es6_module` command (see section 2).
* Configure your client library with the path to the bytecode file and the public key used to sign it.
* Use the client library to send commands to the JSockD server.

### 1.2 Execution model

Commands are cached in the same sort of way that a SQL server caches queries. When a command is executed, the server first checks if the command has been executed before. If it has, the server executes the cached bytecode for that command. If not, the server compiles the command and caches it for future use.

Commands should not mutate global state. Global state may or may not persist across command executions. JSockD reserves the right to reset global state at any time.

## 2. The module compiler

JSockD provides a command-line tool for compiling ES6 modules into QuickJS bytecode files.
Bytecode must be signed using an ED25519 key to ensure that only trusted code is executed
by the server.

Generate a signing key as follows:

```sh
openssl genpkey -algorithm ed25519 -out private_signing_key.pem
openssl pkey -inform pem -pubout -outform der -in private_signing_key.pem | tail -c 32 | xxd -p | tr -d '\n' > public_signing_key
```

**Note that the `openssl` command that comes with MacOS doesn't support the `ed25519` algorithm. You can get a newer openssl via `brew install openssl` and then use `/opt/homebrew/bin/openssl`.**

The JSockD release bundle includes a `compile_es6_module` command that compiles an ES6 module to a QuickJS bytecode file. This command is used to prepare the module that the server will execute. For example:

```sh
compile_es6_module my_module.mjs my_module.quickjs_bytecode private_signing_key.pem
```

**On MacOS you can use `JSOCKD_OPENSSL=/opt/bin/homebrew compile_es6_module ...` to override the default openssl when running the bytecode compiler.**

The value in `public_signing_key` should be passed to `js_server` via the `JSOCKD_BYTECODE_MODULE_PUBLIC_KEY` environment variable.

## 3. The JSockD server

**JSockD is not intended to run as a standalone server; it is designed to be run as a subprocess of an application that needs to execute JavaScript commands. This section is therefore intended as a reference for developers implementing JSockD client libraries.**

The server is started as follows:

```sh
export JSOCKD_BYTECODE_MODULE_PUBLIC_KEY=xxxxx # see next section
js_server <es6_module_bytecode_file> <socket_path> [<socket_path> ...]
```

The first argument is the path to a precompiled ES6 module bytecode file. This module should contain all of the library code that you want commands to be able to reference. In many cases it will be a bundle generated by a build tool such as esbuild.

When the server is ready to start accepting commands on the specified UNIX domain sockets, it prints `READY <N>` to the standard output followed by a line feed. The integer N specifies the number of threads that the server is using to process commands. This may be less than the number of sockets specified, in which case only the first N sockets will be used for command processing.

## 4. The socket protocol

The server listens for commands on the specified UNIX domain sockets. Each command consists of three lines terminated with '\n':

```
<unique command ID>
(module, param) => { ...}
<JSON-encoded parameter>
```

A unique command ID is any sequence of 32 or fewer bytes that does not contain a space character.

The second line, the command, is a JavaScript expression evaluating to a function. The function is called with two arguments.
The first is the module that was loaded from the bytecode file; the second is the parameter passed on the third line.

The third line is the JSON-encoded parameter value.

The server responds with a single line consisting of the command ID followed by a space and then the JSON-encoded result of executing the command.

As the protocol is synchronous, command IDs are not strictly necessary. However, it is recommended to check that responses have the expected
command ID as a means of ensuring that the client code is working correctly.

The client may send either of the following lines to the server at any point:

```
?reset
?quit
```

The `?reset` command resets the server's command parser to its initial state (so that it expects the next line to be a unique command ID).

The `?quit` command causes the server to exit immediately (closing all sockets, not just the socket on which the command was sent).

## 5. Building from source

To build JSockD from source, you must first build QuickJS and then the JS server.

Tools necessary for the build can be installed using [mise-en-place](https://mise.jdx.dev/):

```sh
mise install
```

### 5.1 Building QuickJS

QuickJS is built by running `./build_quickjs.sh`. This script downloads the QuickJS source code, apples some patches, and then builds the QuickJS library. The QuickJS build is kept separate from the main JSockD build because it needs to be run only once, and the QuickJS build system is a bit finicky to configure for different environments.

### 5.2 Building the JS server

This is built using CMake 4. The `mk.sh` wrapper script invokes CMake with the correct arguments for common use cases.

The JS server can be built from within the `js_server` directory as follows:

```sh
npm i # optional, installs clang-format for code formatting
./mk.sh Debug # Debug build
./mk.sh Release # Release build
```

The resulting `js_server` binary can be found in the `build_Release` or `build_Debug` directory. As a convenience, the `mk.sh` script can also run the executable after compilation succeeds:

```sh
./mk.sh Debug run arg1 arg2 ...
```

Unit tests can be run as follows:

```sh
./mk.sh Debug test
```

## 6. Releases

Pre-built binaries are available for download from the [GitHub releases page](https://github.com/addrummond/jsockd/releases). The following platforms are supported:

- Linux x86_64
- Linux ARM64
- macOS ARM64 (Apple Silicon)

To create a new release:

1. Tag the commit with a version tag starting with 'v' (e.g., `v1.0.0`)
2. Push the tag to GitHub: `git push origin v1.0.0`
3. The release workflow will automatically build binaries and create a GitHub release

Each release includes:

- Platform-specific tar.gz archives containing the `js_server` and `compile_es6_module` binaries
- SHA256 checksums for verification
