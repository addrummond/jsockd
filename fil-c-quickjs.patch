diff --git a/Makefile b/Makefile
index 3b1c745..2be9da3 100644
--- a/Makefile
+++ b/Makefile
@@ -222,15 +222,15 @@ ifeq ($(CROSS_PREFIX),)
 ifndef CONFIG_ASAN
 ifndef CONFIG_MSAN
 ifndef CONFIG_UBSAN
-PROGS+=examples/hello examples/test_fib
+#PROGS+=examples/hello examples/test_fib
 # no -m32 option in qjsc
 ifndef CONFIG_M32
 ifndef CONFIG_WIN32
-PROGS+=examples/hello_module
+#PROGS+=examples/hello_module
 endif
 endif
 ifdef CONFIG_SHARED_LIBS
-PROGS+=examples/fib.so examples/point.so
+#PROGS+=examples/fib.so examples/point.so
 endif
 endif
 endif
diff --git a/libregexp.c b/libregexp.c
index 2b33c86..f5466ea 100644
--- a/libregexp.c
+++ b/libregexp.c
@@ -2711,10 +2711,11 @@ static int lre_poll_timeout(REExecContext *s)
 }
 
 /* return 1 if match, 0 if not match or < 0 if error. */
-static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
+// Alex D: Add new out_ret parameter so that we don't return pointers as ints on some return paths and displease Fil-C.
+static int lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                                    StackInt *stack, int stack_len,
                                    const uint8_t *pc, const uint8_t *cptr,
-                                   BOOL no_recurse)
+                                   BOOL no_recurse, uint8_t **out_ret)
 {
     int opcode, ret;
     int cbuf_type;
@@ -2731,8 +2732,10 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
         case REOP_match:
             {
                 REExecState *rs;
-                if (no_recurse)
-                    return (intptr_t)cptr;
+                if (no_recurse) {
+                    *out_ret = (uint8_t *)cptr;
+                    return 1;
+                }
                 ret = 1;
                 goto recurse;
             no_match:
@@ -3111,14 +3114,15 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                 for(;;) {
                     if (lre_poll_timeout(s))
                         return LRE_RET_TIMEOUT;
+                    uint8_t *out_ret = NULL;
                     res = lre_exec_backtrack(s, capture, stack, stack_len,
-                                             pc1, cptr, TRUE);
+                                             pc1, cptr, TRUE, &out_ret);
                     if (res == LRE_RET_MEMORY_ERROR ||
                         res == LRE_RET_TIMEOUT)
                         return res;
                     if (!res)
                         break;
-                    cptr = (uint8_t *)res;
+                    cptr = out_ret;
                     q++;
                     if (q >= quant_max && quant_max != INT32_MAX)
                         break;
@@ -3176,8 +3180,9 @@ int lre_exec(uint8_t **capture,
         capture[i] = NULL;
     alloca_size = s->stack_size_max * sizeof(stack_buf[0]);
     stack_buf = alloca(alloca_size);
+    uint8_t *out_ret;
     ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,
-                             cbuf + (cindex << cbuf_type), FALSE);
+                             cbuf + (cindex << cbuf_type), FALSE, &out_ret);
     lre_realloc(s->opaque, s->state_stack, 0);
     return ret;
 }
diff --git a/quickjs.c b/quickjs.c
index caad931..0ca1753 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -54,6 +54,8 @@
 #else
 #define DIRECT_DISPATCH  1
 #endif
+#undef DIRECT_DISPATCH
+#define DIRECT_DISPATCH 0
 
 #if defined(__APPLE__)
 #define MALLOC_OVERHEAD  0
@@ -875,7 +877,7 @@ typedef struct JSProperty {
         struct {            /* JS_PROP_AUTOINIT */
             /* in order to use only 2 pointers, we compress the realm
                and the init function pointer */
-            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
+            void *realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
                                        in the 2 low bits */
             void *opaque;
         } init;
@@ -5475,12 +5477,13 @@ JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
 
 static JSContext *js_autoinit_get_realm(JSProperty *pr)
 {
-    return (JSContext *)(pr->u.init.realm_and_id & ~3);
+    return (JSContext *)((uintptr_t)pr->u.init.realm_and_id & ~3);
 }
 
 static JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)
 {
-    return pr->u.init.realm_and_id & 3;
+
+    return (uintptr_t)pr->u.init.realm_and_id & 3;
 }
 
 static void js_autoinit_free(JSRuntime *rt, JSProperty *pr)
@@ -9819,10 +9822,10 @@ static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
     pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);
     if (unlikely(!pr))
         return -1;
-    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);
-    assert((pr->u.init.realm_and_id & 3) == 0);
+    pr->u.init.realm_and_id = JS_DupContext(ctx);
+    assert(((uintptr_t)pr->u.init.realm_and_id & 3) == 0);
     assert(id <= 3);
-    pr->u.init.realm_and_id |= id;
+    pr->u.init.realm_and_id = (void*)((uintptr_t)pr->u.init.realm_and_id | id);
     pr->u.init.opaque = opaque;
     return TRUE;
 }
@@ -29055,7 +29058,10 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
         ExportedNameEntry *en = &s->exported_names[i];
         switch(en->export_type) {
         case EXPORTED_NAME_NORMAL:
-            {
+	    // Something about this code spooks Fil-C. Could even be a genuine bug?
+	    // For now we can just resolve all references lazily for Fil-C builds,
+	    // which seems like not the worst thing.
+            /*{
                 JSVarRef *var_ref = en->u.var_ref;
                 pr = add_property(ctx, p, en->export_name,
                                   JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |
@@ -29065,7 +29071,7 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
                 var_ref->header.ref_count++;
                 pr->u.var_ref = var_ref;
             }
-            break;
+            break;*/
         case EXPORTED_NAME_DELAYED:
             /* the exported namespace or reference may depend on
                circular references, so we resolve it lazily */
