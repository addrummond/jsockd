diff --git a/Makefile b/Makefile
index 3b1c745..2be9da3 100644
--- a/Makefile
+++ b/Makefile
@@ -222,15 +222,15 @@ ifeq ($(CROSS_PREFIX),)
 ifndef CONFIG_ASAN
 ifndef CONFIG_MSAN
 ifndef CONFIG_UBSAN
-PROGS+=examples/hello examples/test_fib
+#PROGS+=examples/hello examples/test_fib
 # no -m32 option in qjsc
 ifndef CONFIG_M32
 ifndef CONFIG_WIN32
-PROGS+=examples/hello_module
+#PROGS+=examples/hello_module
 endif
 endif
 ifdef CONFIG_SHARED_LIBS
-PROGS+=examples/fib.so examples/point.so
+#PROGS+=examples/fib.so examples/point.so
 endif
 endif
 endif
diff --git a/libregexp.c b/libregexp.c
index 2b33c86..f5466ea 100644
--- a/libregexp.c
+++ b/libregexp.c
@@ -205,7 +205,7 @@ static __maybe_unused void re_string_list_dump(const char *str, const REStringLi
         }
     }
     printf("]\n");
-    
+
     j = 0;
     for(i = 0; i < s->hash_size; i++) {
         for(p = s->hash_table[i]; p != NULL; p = p->next) {
@@ -352,7 +352,7 @@ static int re_string_list_canonicalize(REParseState *s1,
         REStringList a_s, *a = &a_s;
         int i, j;
         REString *p;
-        
+
         /* XXX: simplify */
         re_string_list_init(s1, a);
 
@@ -360,7 +360,7 @@ static int re_string_list_canonicalize(REParseState *s1,
         a->hash_size = s->hash_size;
         a->hash_bits = s->hash_bits;
         a->hash_table = s->hash_table;
-        
+
         s->n_strings = 0;
         s->hash_size = 0;
         s->hash_bits = 0;
@@ -936,14 +936,14 @@ static int parse_class_string_disjunction(REParseState *s, REStringList *cr,
     const uint8_t *p;
     DynBuf str;
     int c;
-    
+
     p = *pp;
     if (*p != '{')
         return re_parse_error(s, "expecting '{' after \\q");
 
     dbuf_init2(&str, s->opaque, lre_realloc);
     re_string_list_init(s, cr);
-    
+
     p++;
     for(;;) {
         str.size = 0;
@@ -1218,7 +1218,7 @@ static int re_emit_string_list(REParseState *s, const REStringList *sl)
     REString **tab, *p;
     int i, j, split_pos, last_match_pos, n;
     BOOL has_empty_string, is_last;
-    
+
     //    re_string_list_dump("sl", sl);
     if (sl->n_strings == 0) {
         /* simple case: only characters */
@@ -1244,7 +1244,7 @@ static int re_emit_string_list(REParseState *s, const REStringList *sl)
             }
         }
         assert(n <= sl->n_strings);
-        
+
         rqsort(tab, n, sizeof(tab[0]), re_string_cmp_len, NULL);
 
         last_match_pos = -1;
@@ -1285,7 +1285,7 @@ static int re_emit_string_list(REParseState *s, const REStringList *sl)
             put_u32(s->byte_code.buf + last_match_pos, s->byte_code.size - (last_match_pos + 4));
             last_match_pos = next_pos;
         }
-        
+
         lre_realloc(s->opaque, tab, 0);
     }
     return 0;
@@ -1297,7 +1297,7 @@ static int re_parse_class_set_operand(REParseState *s, REStringList *cr, const u
 {
     int c1;
     const uint8_t *p = *pp;
-    
+
     if (*p == '[') {
         if (re_parse_nested_class(s, cr, pp))
             return -1;
@@ -1339,7 +1339,7 @@ static int re_parse_nested_class(REParseState *s, REStringList *cr, const uint8_
         p++;
         invert = TRUE;
     }
-    
+
     /* handle unions */
     is_first = TRUE;
     for(;;) {
@@ -2066,7 +2066,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
             emit_back_reference:
                 last_atom_start = s->byte_code.size;
                 last_capture_count = s->capture_count;
-                
+
                 re_emit_op_u8(s, REOP_back_reference + 2 * is_backward_dir + s->ignore_case, c);
             }
             break;
@@ -2711,10 +2711,11 @@ static int lre_poll_timeout(REExecContext *s)
 }
 
 /* return 1 if match, 0 if not match or < 0 if error. */
-static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
+// Alex D: Add new out_ret parameter so that we don't return pointers as ints on some return paths and displease Fil-C.
+static int lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                                    StackInt *stack, int stack_len,
                                    const uint8_t *pc, const uint8_t *cptr,
-                                   BOOL no_recurse)
+                                   BOOL no_recurse, uint8_t **out_ret)
 {
     int opcode, ret;
     int cbuf_type;
@@ -2731,8 +2732,10 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
         case REOP_match:
             {
                 REExecState *rs;
-                if (no_recurse)
-                    return (intptr_t)cptr;
+                if (no_recurse) {
+                    *out_ret = (uint8_t *)cptr;
+                    return 1;
+                }
                 ret = 1;
                 goto recurse;
             no_match:
@@ -3111,14 +3114,15 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                 for(;;) {
                     if (lre_poll_timeout(s))
                         return LRE_RET_TIMEOUT;
+                    uint8_t *out_ret = NULL;
                     res = lre_exec_backtrack(s, capture, stack, stack_len,
-                                             pc1, cptr, TRUE);
+                                             pc1, cptr, TRUE, &out_ret);
                     if (res == LRE_RET_MEMORY_ERROR ||
                         res == LRE_RET_TIMEOUT)
                         return res;
                     if (!res)
                         break;
-                    cptr = (uint8_t *)res;
+                    cptr = out_ret;
                     q++;
                     if (q >= quant_max && quant_max != INT32_MAX)
                         break;
@@ -3176,8 +3180,9 @@ int lre_exec(uint8_t **capture,
         capture[i] = NULL;
     alloca_size = s->stack_size_max * sizeof(stack_buf[0]);
     stack_buf = alloca(alloca_size);
+    uint8_t *out_ret;
     ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,
-                             cbuf + (cindex << cbuf_type), FALSE);
+                             cbuf + (cindex << cbuf_type), FALSE, &out_ret);
     lre_realloc(s->opaque, s->state_stack, 0);
     return ret;
 }
diff --git a/quickjs.c b/quickjs.c
index caad931..0ca1753 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -54,6 +54,8 @@
 #else
 #define DIRECT_DISPATCH  1
 #endif
+#undef DIRECT_DISPATCH
+#define DIRECT_DISPATCH 0
 
 #if defined(__APPLE__)
 #define MALLOC_OVERHEAD  0
@@ -69,7 +71,7 @@
 /* define to include Atomics.* operations which depend on the OS
    threads */
 #if !defined(EMSCRIPTEN)
-#define CONFIG_ATOMICS
+#undef CONFIG_ATOMICS // Alex D - keep size down (don't need this)
 #endif
 
 #if !defined(EMSCRIPTEN)
@@ -875,7 +877,7 @@ typedef struct JSProperty {
         struct {            /* JS_PROP_AUTOINIT */
             /* in order to use only 2 pointers, we compress the realm
                and the init function pointer */
-            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
+            void *realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
                                        in the 2 low bits */
             void *opaque;
         } init;
@@ -5475,12 +5477,13 @@ JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
 
 static JSContext *js_autoinit_get_realm(JSProperty *pr)
 {
-    return (JSContext *)(pr->u.init.realm_and_id & ~3);
+    return (JSContext *)((uintptr_t)pr->u.init.realm_and_id & ~3);
 }
 
 static JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)
 {
-    return pr->u.init.realm_and_id & 3;
+
+    return (uintptr_t)pr->u.init.realm_and_id & 3;
 }
 
 static void js_autoinit_free(JSRuntime *rt, JSProperty *pr)
@@ -9819,10 +9822,10 @@ static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
     pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);
     if (unlikely(!pr))
         return -1;
-    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);
-    assert((pr->u.init.realm_and_id & 3) == 0);
+    pr->u.init.realm_and_id = JS_DupContext(ctx);
+    assert(((uintptr_t)pr->u.init.realm_and_id & 3) == 0);
     assert(id <= 3);
-    pr->u.init.realm_and_id |= id;
+    pr->u.init.realm_and_id = (void*)((uintptr_t)pr->u.init.realm_and_id | id);
     pr->u.init.opaque = opaque;
     return TRUE;
 }
@@ -29055,7 +29058,10 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
         ExportedNameEntry *en = &s->exported_names[i];
         switch(en->export_type) {
         case EXPORTED_NAME_NORMAL:
-            {
+	    // Something about this code spooks Fil-C. Could even be a genuine bug?
+	    // For now we can just resolve all references lazily for Fil-C builds,
+	    // which seems like not the worst thing.
+            /*{
                 JSVarRef *var_ref = en->u.var_ref;
                 pr = add_property(ctx, p, en->export_name,
                                   JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |
@@ -29065,7 +29071,7 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
                 var_ref->header.ref_count++;
                 pr->u.var_ref = var_ref;
             }
-            break;
+            break;*/
         case EXPORTED_NAME_DELAYED:
             /* the exported namespace or reference may depend on
                circular references, so we resolve it lazily */
