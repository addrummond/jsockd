diff --git a/Makefile b/Makefile
index 3b1c745..2be9da3 100644
--- a/Makefile
+++ b/Makefile
@@ -222,15 +222,15 @@ ifeq ($(CROSS_PREFIX),)
 ifndef CONFIG_ASAN
 ifndef CONFIG_MSAN
 ifndef CONFIG_UBSAN
-PROGS+=examples/hello examples/test_fib
+#PROGS+=examples/hello examples/test_fib
 # no -m32 option in qjsc
 ifndef CONFIG_M32
 ifndef CONFIG_WIN32
-PROGS+=examples/hello_module
+#PROGS+=examples/hello_module
 endif
 endif
 ifdef CONFIG_SHARED_LIBS
-PROGS+=examples/fib.so examples/point.so
+#PROGS+=examples/fib.so examples/point.so
 endif
 endif
 endif
diff --git a/cutils.c b/cutils.c
index c038cf4..458b122 100644
--- a/cutils.c
+++ b/cutils.c
@@ -630,4 +630,11 @@ void rqsort(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)
     }
 }
 
+void patched_rqsort(void *base, size_t nmemb, size_t size,
+            int (*cmp)(const void *, const void *, void *),
+            void *arg)
+{
+    qsort_r(base, nmemb, size, cmp, arg);
+}
+
 #endif
diff --git a/cutils.h b/cutils.h
index 9fcb7a6..84db494 100644
--- a/cutils.h
+++ b/cutils.h
@@ -420,4 +420,8 @@ static inline int isfp16zero(uint16_t v)
     return (v & 0x7FFF) == 0;
 }
 
+void patched_rqsort(void *base, size_t nmemb, size_t size,
+            int (*cmp)(const void *, const void *, void *),
+            void *arg);
+
 #endif  /* CUTILS_H */
diff --git a/libregexp.c b/libregexp.c
index 2b33c86..2254199 100644
--- a/libregexp.c
+++ b/libregexp.c
@@ -2711,10 +2711,11 @@ static int lre_poll_timeout(REExecContext *s)
 }
 
 /* return 1 if match, 0 if not match or < 0 if error. */
-static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
+// Alex D: Add new out_ret parameter so that we don't return pointers as ints on some return paths and displease Fil-C.
+static int lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                                    StackInt *stack, int stack_len,
                                    const uint8_t *pc, const uint8_t *cptr,
-                                   BOOL no_recurse)
+                                   BOOL no_recurse, uint8_t **out_ret)
 {
     int opcode, ret;
     int cbuf_type;
@@ -2731,8 +2732,10 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
         case REOP_match:
             {
                 REExecState *rs;
-                if (no_recurse)
-                    return (intptr_t)cptr;
+                if (no_recurse) {
+                    *out_ret = (uint8_t *)cptr;
+                    return 1;
+                }
                 ret = 1;
                 goto recurse;
             no_match:
@@ -3111,14 +3114,15 @@ static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                 for(;;) {
                     if (lre_poll_timeout(s))
                         return LRE_RET_TIMEOUT;
+                    uint8_t *out_ret = NULL;
                     res = lre_exec_backtrack(s, capture, stack, stack_len,
-                                             pc1, cptr, TRUE);
+                                             pc1, cptr, TRUE, &out_ret);
                     if (res == LRE_RET_MEMORY_ERROR ||
                         res == LRE_RET_TIMEOUT)
                         return res;
                     if (!res)
                         break;
-                    cptr = (uint8_t *)res;
+                    cptr = out_ret;
                     q++;
                     if (q >= quant_max && quant_max != INT32_MAX)
                         break;
@@ -3176,8 +3180,9 @@ int lre_exec(uint8_t **capture,
         capture[i] = NULL;
     alloca_size = s->stack_size_max * sizeof(stack_buf[0]);
     stack_buf = alloca(alloca_size);
+    uint8_t *out_ret;
     ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,
-                             cbuf + (cindex << cbuf_type), FALSE);
+                             cbuf + (cindex << cbuf_type), FALSE, &out_ret);
     lre_realloc(s->opaque, s->state_stack, 0);
     return ret;
 }
diff --git a/quickjs.c b/quickjs.c
index caad931..f131366 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -54,6 +54,8 @@
 #else
 #define DIRECT_DISPATCH  1
 #endif
+#undef DIRECT_DISPATCH
+#define DIRECT_DISPATCH 0
 
 #if defined(__APPLE__)
 #define MALLOC_OVERHEAD  0
@@ -76,6 +78,7 @@
 /* enable stack limitation */
 #define CONFIG_STACK_CHECK
 #endif
+#undef CONFIG_STACK_CHECK // doesn't play well with Fil-C
 
 
 /* dump object free */
@@ -875,7 +878,7 @@ typedef struct JSProperty {
         struct {            /* JS_PROP_AUTOINIT */
             /* in order to use only 2 pointers, we compress the realm
                and the init function pointer */
-            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
+            void *realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
                                        in the 2 low bits */
             void *opaque;
         } init;
@@ -5475,12 +5478,13 @@ JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
 
 static JSContext *js_autoinit_get_realm(JSProperty *pr)
 {
-    return (JSContext *)(pr->u.init.realm_and_id & ~3);
+    return (JSContext *)((uintptr_t)pr->u.init.realm_and_id & ~3);
 }
 
 static JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)
 {
-    return pr->u.init.realm_and_id & 3;
+
+    return (uintptr_t)pr->u.init.realm_and_id & 3;
 }
 
 static void js_autoinit_free(JSRuntime *rt, JSProperty *pr)
@@ -8133,7 +8137,7 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
     assert(sym_index == atom_count);
 
     if (num_keys_count != 0 && !num_sorted) {
-        rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp,
+        patched_rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp,
                ctx);
     }
     *ptab = tab_atom;
@@ -9819,10 +9823,10 @@ static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
     pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);
     if (unlikely(!pr))
         return -1;
-    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);
-    assert((pr->u.init.realm_and_id & 3) == 0);
+    pr->u.init.realm_and_id = JS_DupContext(ctx);
+    assert(((uintptr_t)pr->u.init.realm_and_id & 3) == 0);
     assert(id <= 3);
-    pr->u.init.realm_and_id |= id;
+    pr->u.init.realm_and_id = (void*)((uintptr_t)pr->u.init.realm_and_id | id);
     pr->u.init.opaque = opaque;
     return TRUE;
 }
@@ -29048,7 +29052,7 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
     }
 
     /* sort the exported names */
-    rqsort(s->exported_names, s->exported_names_count,
+    patched_rqsort(s->exported_names, s->exported_names_count,
            sizeof(s->exported_names[0]), exported_names_cmp, ctx);
 
     for(i = 0; i < s->exported_names_count; i++) {
@@ -29958,7 +29962,7 @@ static JSValue js_async_module_execution_fulfilled(JSContext *ctx, JSValueConst
     }
 
     /* sort by increasing async_evaluation timestamp */
-    rqsort(exec_list->tab, exec_list->count, sizeof(exec_list->tab[0]),
+    patched_rqsort(exec_list->tab, exec_list->count, sizeof(exec_list->tab[0]),
            exec_module_list_cmp, NULL);
 
     for(i = 0; i < exec_list->count; i++) {
@@ -41831,7 +41835,7 @@ static JSValue js_array_sort(JSContext *ctx, JSValueConst this_val,
         array[pos].pos = i;
         pos++;
     }
-    rqsort(array, pos, sizeof(*array), js_array_cmp_generic, &asc);
+    patched_rqsort(array, pos, sizeof(*array), js_array_cmp_generic, &asc);
     if (asc.exception)
         goto exception;
 
@@ -54391,7 +54395,7 @@ static JSValue js_typed_array_sort(JSContext *ctx, JSValueConst this_val,
                 array_idx[i] = i;
             tsc.array_ptr = array_ptr;
             tsc.elt_size = elt_size;
-            rqsort(array_idx, len, sizeof(array_idx[0]),
+            patched_rqsort(array_idx, len, sizeof(array_idx[0]),
                    js_TA_cmp_generic, &tsc);
             if (tsc.exception) {
                 if (tsc.exception == 1)
@@ -54437,7 +54441,7 @@ static JSValue js_typed_array_sort(JSContext *ctx, JSValueConst this_val,
             }
             js_free(ctx, array_idx);
         } else {
-            rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
+            patched_rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
             if (tsc.exception)
                 return JS_EXCEPTION;
         }
